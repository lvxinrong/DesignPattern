# DesignPattern

* 这个库用于自己学习设计模式建的，一直没有把自己的理解整理出来所以整理一下

### 单例模式 
__单例模式，个人对单例的最大的体会就是构造器的私有，保证外部无法创建类的实例，保证了在系统中只存在唯一的一个实体对象。比如数据库的连接池，多线程的线程池
目的是减少大对象的创建销毁过程中造成的资源损耗。或者说方便类对创建对象的控制比如线程池__
* 单例模式一共收集到七中写法，因为很少会有单线程下的单例的使用，所以基本上都都要考虑到多线程，并发时候，单例的创建。恶汉式在某种程度上是解决了并发的问题
但是如果说所创建的对象非常大，采用恶汉式就会在系统启动的时候造成不必要的浪费，所以一般的写法都是在基础懒汉式的模式上进行改造，比如synchornized的加锁，
可以看com.singleton.version.SingleTon_2的写法，直接在获取实例的方法上进行加锁。这样的写法虽然说解决了并发安全的问题，但是因为锁的粒度相对而言还是比较大
因为判断实例是否为null的操作是没有必要放在锁中的，因为有了第三种写法,SingleTon_3的写法就是减小锁的粒度，但是（我在学习单例的时候看到但是就内心一颤，卧槽
都特么写成这样了也不行，继续看）因为new的过程中，可能会产生指令重排，new的过程分为三步，1给 SingleTon分配内存，2调用SingleTon的构造函数生成实例 3，
将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了），因为singleTon没有声明为voliate的类型，这里可能会3在2之前发生，也就是说这个时候
如果再有一个线程来获取实例，可能会返回null，这时，就有了voliate去声明这个唯一的单例，产生了第四种单例的写法 SingleTon_4.其实这种写法，在使用上已经没有
问题了(反正我不打包票，谁知道以后会怎么样呢)但是写法不优雅，不好看。哈哈哈，果然给了我一种永无止境的感觉，感觉贼high。
这里提出了第五种写法，是出现在Effective Java 中，作者提出的一种单例写法，看完之后，叹为观止。思路就是恶汉式和懒汉是的结合，创建一个内部类，内部类中采用
饿汉式返回实例，但是在外部类的获取实例方法来看又是懒汉式，并且内部类是静态的，也就是说通过ClassLoader来保证同步。不行了，我要把这段代码放出来:
```
public class SingleTon_5 {
	/**
	 * 对于内部类SingleTonInstance，它是一个饿汉式的单例实现，在SingleTonInstance初始化的时候会由ClassLoader来保证同步，使INSTANCE是一个真·单例。
     * 同时，由于SingleTonInstance是一个内部类，只在外部类的SingleTon_5的getInstance()中被使用，所以它被加载的时机也就是在getInstance()方法第一次被调用的时候。
     * 它利用了ClassLoader来保证了同步，同时又能让开发者控制类加载的时机。从内部看是一个饿汉式的单例，但是从外部看来，又的确是懒汉式的实现。
	 *   简直是神乎其技。
	 */
	private static class SingleTonInstance {
		//这里如果抛出异常，则会导致得不到实例
		private static SingleTon_5 INSTANCE = new SingleTon_5();
	}
	
	public static SingleTon_5 getInstance() {
		return SingleTonInstance.INSTANCE;
	}
	
	/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ 
	public Object readResolve() {  
        return getInstance();  
    }  
	/**
	 * 没有最完美的写法，只有最合适的写法，如果单线程情况下，那么第一种懒汉式就完全够用了，
	 * 学无止境吧
	 */
}
```
### 工厂模式
__工厂模式，个人对工厂模式的理解就是，讲相关类的创建统一到一个类中控制，便于以后的修改。尤其是几个类同时创建来完成一个事的时候，比方说最常见的组装
总是有人拿汽车工厂来比喻工厂模式，我总是纳闷为啥不用罐头厂呢，哈哈哈哈。__
* 工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。著名的Jive论坛 ,就大量使用了工厂模式，工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。
* 工厂模式一般有，工厂模式和抽象工厂，静态工厂 ，其实工厂就是通过父类创建具体的子类，这叫啥来着，多态。对相似的类进行一次抽象，建立父类，然后工厂类的创建方法的返回值一般就是返回这个父类，不过在方法中可以返回具体的子类，理解了多态其实理解工厂模式就没什么难度了，这里特意说一下抽象工厂，抽象工厂其实在个人看来是对工厂类的再次抽象，以更符合开闭原则。就是不修改已有的代码，通过建立新代码来完成功能上的修改。不一定对啊，别乱信，抽象的思想真的很重要很重要非常重要。
* 静态工厂就是不用创建工厂的实例，直接调用工厂类的静态方法返回实例就好了。



### 代理模式 
* 代理模式 代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。（来自百度百科哟）
* 代理模式有静态代理和动态代理。静态代理就是提前写好了Proxy类，使用就是了，动态代理就是在程序执行的过程中创建代理类。动态代理的实现方法知道两种 JDK动态代理和CGlib 两者之间的区别蛮大的 有:
    1.JDK的动态代理的代理类必须有一个实现的接口，而CGLib创建代理类，被代理类无需接口
    2.性能问题，但是这里有一篇博文支出JDK动态代理在性能上随着jdk版本的升级而不停的在提升[JDK动态代理的性能测试](http://www.cnblogs.com/haiq/p/4304615.html)
* 静态代理就不用说了，这个也没什么好说的，就是实现被代理类的通用接口，持有被代理的实例，然后方法进行处理。

* 动态代理 先来说说JDK动态代理，JDK动态代理是代理类实现 InvocationHandler 接口，具体的代码可以在com.dynamic.version.MyInvocationHandler中看到，最重要的一个方法就是
```
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable 
//其实我对动态代理的内部究竟是如何去实现的也不知道，尴尬，只是知道是怎么回事，包中提供了一个类（ProxyGeneratorUtils），可以将动态代理类输出到本地磁盘上，厉害吧，抄别人的
```
* CGLib的代理，其实个人感觉用于补充 JDK动态代理必须有接口的这个问题，可以对没有接口的类也进行代理。不过学习过程中倒是真的理解了代理模式的原则，很大的收获





